#!/usr/bin/env python2

import sys
import os
import os.path
import errno
import argparse
import glob
from common import *

# bakcontent-store-server: Store (server)
# - After transfer, check FRESH files have correct md5. Move to correct md5 name to
# FINAL store. It's not an error when it happens on freshly transferred files,
# as the client does not protect against races (write-while-uploading). It's a
# storage error if such a discrepancy is discoverd on known-good md5.

def global_register(bakdir):
    bakdir = os.path.realpath(bakdir)

    rcdir = os.path.join(os.path.expanduser('~'), '.bakcontentrc')
    trymakedirs(rcdir)

    with pushdir(rcdir):
        paths = set()
        try:
            with open('list') as f:
                paths = set(f.read().strip().split())
        except:
            pass

        if bakdir in paths:
            return
        paths.add(bakdir)

        with atomicopenw('list') as f:
            f.write('\n'.join(paths) + '\n')

        with open('list') as f:
            paths = set(f.readlines())
        if bakdir not in paths:
            # Retry.
            global_register(bakdir)

def global_unregister(bakdir):
    bakdir = os.path.realpath(bakdir)

    rcdir = os.path.join(os.path.expanduser('~'), '.bakcontentrc')
    if not os.path.isdir(rcdir):
        eprint("cannot unregister '%s': no global '%s'" % (bakdir, rcdir))
        exit(1)

    with pushdir(rcdir):
        paths = set()
        try:
            with open('list') as f:
                paths = set(f.read().strip().split())
        except:
            pass

        paths.discard(bakdir)

        with atomicopenw('list') as f:
            f.write('\n'.join(paths) + '\n')

        with open('list') as f:
            paths = set(f.readlines())
        if bakdir in paths:
            # Retry.
            global_unregister(bakdir)

def register(args):
    argparser = argparse.ArgumentParser()
    args_default(argparser)
    argparser.add_argument('--root', nargs='?',
            help='current dir if omitted')
    cmdargs = argparser.parse_args(args)

    bakdir = cmdargs.bakcontent
    if cmdargs.root is None:
        rootdir = '..'
    else:
        if os.path.isabs(cmdargs.root):
            rootdir = cmdargs.root
        else:
            rootdir = os.path.join('..', cmdargs.root)

    nobak = os.path.join(rootdir, '.nobakcontent')
    if os.path.exists(nobak):
        eprint("Error: '%s' exists, cannot register")

    if not os.path.isdir(bakdir):
        try:
            os.makedirs(bakdir)
        except OSError, e:
            eprint("Error: cannot init '%s': %s" % (bakdir, e))
            exit(1)

    with pushdir(bakdir):
        with atomicopenw('root') as f:
            f.write(os.path.realpath(rootdir) + '\n')

    histdir = os.path.join(bakdir, 'history')
    if not os.path.isdir(histdir):
        os.makedirs(histdir)
        with pushdir(histdir):
            e = shell('git init')
            if e:
                exit(e)
            e = shell('git config --add gc.auto 1000')
            if e:
                exit(e)
            e = shell('git config --add pack.packSizeLimit 1m')
            if e:
                exit(e)

    store_add(bakdir, ['default', os.path.join(bakdir, 'default')])

    global_register(bakdir)

def unregister(args):
    argparser = argparse.ArgumentParser()
    args_default(argparser)
    cmdargs = argparser.parse_args(args)

    bakdir = args_parse_dirs(cmdargs)

    global_unregister(bakdir)

def snapshot(args):
    argparser = argparse.ArgumentParser()
    args_default(argparser)
    cmdargs = argparser.parse_args(args)

    bakdir = args_parse_dirs(cmdargs)
    bakdir = os.path.realpath(bakdir)
    e = shell("bakcontent-do '%s' snapshot" % bakdir)
    if e:
        exit(e)

def store_add(bakdir, args):
    argparser = argparse.ArgumentParser()
    argparser.add_argument('name',
            help='store name')
    argparser.add_argument('spec',
            help='store specification (path for local, s3://, ssh://)')
    cmdargs = argparser.parse_args(args)

    store = Store(bakdir, cmdargs.name, cmdargs.spec)
    store.add()

def store_rm(bakdir, args):
    argparser = argparse.ArgumentParser()
    argparser.add_argument('name',
            help='store name')
    cmdargs = argparser.parse_args(args)

    store = Store(bakdir, cmdargs.name)
    store.rm()

def store_ls(bakdir):
    with pushdir(bakdir):
        for sfn in glob.glob('stores/*'):
            with open(sfn) as f:
                sn = os.path.basename(sfn)
                spec = f.read().strip()
                print sn, spec

def store_sync(bakdir, args):
    argparser = argparse.ArgumentParser()
    argparser.add_argument('name', nargs='?', default='default',
            help='store name')
    cmdargs = argparser.parse_args(args)

    bakdir = os.path.realpath(bakdir)
    e = shell("bakcontent-do '%s' store-sync %s" % (bakdir, cmdargs.name))
    if e:
        exit(e)

def store(args):
    argparser = argparse.ArgumentParser()
    args_default(argparser)
    argparser.add_argument('store_cmd', nargs='?', default='sync',
            help='sync (default), add, rm, ls')
    argparser.add_argument('args', nargs='*',
            help="cmd arguments (e.g. 'help')")
    cmdargs = argparser.parse_args(args)

    bakdir = args_parse_dirs(cmdargs)
    further_args = cmdargs.args

    if cmdargs.store_cmd == 'sync':
        store_sync(bakdir, further_args)
    elif cmdargs.store_cmd == 'add':
        store_add(bakdir, further_args)
    elif cmdargs.store_cmd == 'rm':
        store_rm(bakdir, further_args)
    elif cmdargs.store_cmd == 'ls':
        store_ls(bakdir)

def main():
    if len(sys.argv) < 2:
        eprint("Usage: %s <cmd> [args...]")
        exit(1)

    cmd = sys.argv[1]
    further_args = sys.argv[2:]

    if cmd == 'register':
        register(further_args)
    elif cmd == 'unregister':
        unregister(further_args)
    elif cmd == 'snapshot':
        snapshot(further_args)
    elif cmd == 'store':
        store(further_args)
    else:
        eprint("Error: invalid command '%s'" % cmd)
        exit(1)

if __name__ == '__main__':
    main()
