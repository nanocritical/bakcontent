#!/usr/bin/python

import re
import os
import os.path
import sys
import shutil
import tempfile
import subprocess
import socket
import errno
import getopt

import history
import stores.disk

# SNAPSHOT
# - Create content temporary copy in same directory to avoid races if original modified later.
# - Compute hash.
# - Rename content temporary using the hash (still in same dir).
# - Commit metadata.

# STORE
# - Then copy content to backing store.

# BACKUP = SNAPSHOT + STORE


BAKPREFIX = '.bakcontent'
TMP_BAKPREFIX = BAKPREFIX + '_'
TMP_NO_HASH_BAKPREFIX = BAKPREFIX + '_tmp_'
DO_NOT_BACKUP = BAKPREFIX + '_donotbackup'

g_hostname, g_full_hostname = socket.gethostname(), socket.getfqdn()

def create_content_tmp(basedir, filename):
  '''Copy to a temporary name first, to avoid any races.'''
  fn = os.path.join(basedir, filename)
  content, tmp_cfn = tempfile.mkstemp(prefix=TMP_NO_HASH_BAKPREFIX, dir=os.path.dirname(fn))

  content = os.fdopen(content)

  if os.path.islink(fn):
    with content:
      content.write(unicode(os.readlink(fn)))
  else:
    content.close()
    shutil.copy2(fn, tmp_cfn)

  h = subprocess.check_output(['md5sum', tmp_cfn]).split()[0]

  h_tmp_cfn = os.path.join(os.path.dirname(fn), TMP_BAKPREFIX + h)
  # Not moved to the backing store yet, even if it were local,
  # because it could be slow if the store is not on the same
  # partition, say.
  os.rename(tmp_cfn, h_tmp_cfn)

  return h_tmp_cfn, h

def stat_list(cfn):
  r = []
  s = os.stat(cfn)
  # We store the size to facilitate integrity checks.
  for st in 'st_size st_mode st_uid st_gid st_atime st_mtime st_ctime'.split():
    r.append(str(getattr(s, st)))
  return r

def meta_fn(hist, fn):
  return os.path.join(hist.metadir, fn)

def write_meta(m, h, sl):
  m.write(h + '\n')
  m.write(' '.join(sl) + '\n')
  m.write(g_hostname + ' ' + g_full_hostname + '\n')

def create_meta(hist, fn, h, tmp_cfn):
  mfn = meta_fn(hist, fn)
  try:
    os.makedirs(os.path.dirname(mfn))
  except OSError, e:
    if e.errno != errno.EEXIST:
      raise e

  with open(mfn, 'w') as m:
    write_meta(m, h, stat_list(tmp_cfn))

  shutil.copystat(tmp_cfn, mfn)

class Snap(object):
  def __init__(self, fn, h, tmp_cfn):
    self.fn = fn
    self.h = h
    self.tmp_cfn = tmp_cfn

  @classmethod
  def from_content_tmp_only(cls, tmp_cfn):
    bn = os.path.basename(tmp_cfn)
    assert bn.startswith(TMP_BAKPREFIX)
    h = re.sub(r'^' + TMP_BAKPREFIX, '', bn)
    return cls(None, h, tmp_cfn)

def snapshot_file(hist, basedir, fn):
  tmp_cfn, h = create_content_tmp(basedir, fn)
  create_meta(hist, fn, h, tmp_cfn)
  return Snap(fn, h, tmp_cfn)

def snapshot_multiple_files(hist, basedir, fns):
  snaps = []
  for fn in fns:
    snaps.append(snapshot_file(hist, basedir, fn))

  for snap in snaps:
    hist.add_meta(snap.fn)
  hist.commit()

  return snaps

def store_multiple_files(store, basedir, fns):
  snaps = map(Snap.from_content_tmp_only, fns)

  for snap in snaps:
    store.save_content(snap.h, snap.tmp_cfn)

def backup_multiple_files(store, hist, basedir, fns):
  snaps = snapshot_multiple_files(hist, basedir, fns)

  for snap in snaps:
    store.save_content(snap.h, snap.tmp_cfn)

def gather_all_files(basedir, filter=None, _dest=None):
  if not os.path.isdir(basedir):
    raise Exception("Argument '%s' is not a directory" % e)
  if os.path.isfile(os.path.join(basedir, DO_NOT_BACKUP)):
    raise Exception("Directory '%s' is marked with file '%s'" % (basedir, DO_NOT_BACKUP))

  fns = _dest or []
  for root, dirs, files in os.walk(basedir):
    if os.path.isfile(os.path.join(root, DO_NOT_BACKUP)):
      continue

    relroot = os.path.relpath(root, basedir)
    for f in files:
      full = os.path.join(relroot, f)
      if filter is None or filter(basedir, full):
        fns.append(full)

    try:
      dirs.remove(BAKPREFIX)
    except ValueError:
      pass
  return fns

def filter_out_bakcontent_files(basedir, fn):
  return not fn.startswith(BAKPREFIX)

def filter_content_tmp(basedir, fn):
  return os.path.basename(fn).startswith(TMP_BAKPREFIX)

def command(cmd, args, **kw):
  if cmd == 'backup':
    assert len(args) == 1 and os.path.isdir(args[0])  # Only support backing up one dir recursively for now.

    basedir = args[0]
    hist = history.History(os.path.join(basedir, BAKPREFIX, 'history'))
    store = stores.disk.Disk(os.path.join(basedir, BAKPREFIX, 'content'))

    fns = gather_all_files(basedir, filter=filter_out_bakcontent_files)
    backup_multiple_files(store, hist, basedir, fns)

  elif cmd == 'snapshot':
    assert len(args) == 1 and os.path.isdir(args[0])  # Only support backing up one dir recursively for now.

    basedir = args[0]
    hist = history.History(os.path.join(basedir, BAKPREFIX, 'history'))

    fns = gather_all_files(basedir, filter=filter_out_bakcontent_files)
    snapshot_multiple_files(hist, basedir, fns)

  elif cmd == 'store':
    assert len(args) == 1 and os.path.isdir(args[0])  # Only support backing up one dir recursively for now.

    basedir = args[0]
    store = stores.disk.Disk(os.path.join(basedir, BAKPREFIX, 'content'))

    fns = gather_all_files(basedir, filter=filter_content_tmp)
    store_multiple_files(store, basedir, fns)

  else:
    print '''Usage: %s <cmd> args...
Commands:
  backup [--store <backing_store>] <directory>
        Snapshot and store <directory>.
  snapshot <directory>
        Snapshot <directory>.
  store [--store <backing_store>] <directory>
        Push the snapshots in <directory> to the backing store.
  help
        This message.
''' % sys.argv[0]


if __name__ == '__main__':
  if len(sys.argv) == 1:
    sys.exit(command('help', []))
  else:
    cmd = sys.argv[1]
    opts, args = getopt.getopt(sys.argv[2:], None, ['store='])
    sys.exit(command(cmd, args, **dict(opts)))
